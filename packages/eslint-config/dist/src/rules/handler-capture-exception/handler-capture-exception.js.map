{"version":3,"file":"handler-capture-exception.js","sourceRoot":"/","sources":["src/rules/handler-capture-exception/handler-capture-exception.ts"],"names":[],"mappings":";;;AAEA;;;;GAIG;AAEH,MAAM,aAAa,GAAG,CAAC,QAAgB,EAAE,EAAE,CACzC,IAAI,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AASlC,QAAA,2BAA2B,GAAgC;IACtE,2BAA2B,EAAE;QAC3B,IAAI,EAAE,2BAA2B;QACjC,IAAI,EAAE;YACJ,IAAI,EAAE,SAAS;YACf,QAAQ,EAAE;gBACR,gCAAgC,EAC9B,6DAA6D;aAChE;YACD,MAAM,EAAE,EAAE;YACV,IAAI,EAAE;gBACJ,WAAW,EACT,6DAA6D;aAChE;SACF;QACD,cAAc,EAAE,EAAE;QAClB,MAAM,EAAE,UAAU,OAAyC;YACzD,OAAO;gBACL,gFAAgF;gBAChF,6EAA6E;gBAC7E,2EAA2E;gBAC3E,cAAc,CAAC,IAAsB;oBACnC,MAAM,QAAQ,GAAG,OAAO,CAAC,mBAAmB;wBAC1C,CAAC,CAAC,OAAO,CAAC,mBAAmB,EAAE;wBAC/B,CAAC,CAAC,OAAO,CAAC,WAAW,EAAE,CAAC;oBAE1B,IAAI,aAAa,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,MAAM,EAAE;wBAC1C,MAAM,sBAAsB,GAAG,IAAI,CAAC,MAAM;6BACvC,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,IAAI,KAAK,YAAY,CAAC;6BAC9C,MAAM,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,KAAK,kBAAkB,CAAC,CAAC;wBAEzD,+EAA+E;wBAC/E,uEAAuE;wBACvE,IAAI,sBAAsB,CAAC,MAAM,GAAG,CAAC,EAAE;4BACrC,OAAO,CAAC,MAAM,CAAC;gCACb,IAAI;gCACJ,SAAS,EAAE,kCAAkC;6BAC9C,CAAC,CAAC;yBACJ;qBACF;gBACH,CAAC;aACF,CAAC;QACJ,CAAC;KACF;CACF,CAAC","sourcesContent":["import { ESLintUtils, TSESLint, TSESTree } from \"@typescript-eslint/utils\";\n\n/**\n * Check if the file being tested is a lambda handler file. We'll do this by\n * checking if the file is located in a directory with `/src/handlers/` or\n * `/src/handler/` in the path.\n */\n\nconst isHandlerFile = (fileName: string) =>\n  new RegExp(\"/src/handlers?/\").test(fileName);\n\ntype HandlerCaptureExceptionRule = {\n  \"handler-capture-exception\": ESLintUtils.RuleWithMetaAndName<\n    [],\n    \"wrapFunctionWithCaptureException\"\n  >;\n};\n\nexport const handlerCaptureExceptionRule: HandlerCaptureExceptionRule = {\n  \"handler-capture-exception\": {\n    name: \"Handler Capture Exception\",\n    meta: {\n      type: \"problem\",\n      messages: {\n        wrapFunctionWithCaptureException:\n          \"Handlers must be wrapped by the captureException() function\",\n      },\n      schema: [],\n      docs: {\n        description:\n          \"Handlers must be wrapped by the captureException() function\",\n      },\n    },\n    defaultOptions: [],\n    create: function (context: TSESLint.RuleContext<string, []>) {\n      return {\n        // ðŸŽ¯ TODO: This could be improved upon as it only checks the `captureException`\n        // function is imported and called in the scope of a handler file. It doesn't\n        // actually check that the exported handler is composed using the function.\n        \"Program:exit\"(node: TSESTree.Program) {\n          const fileName = context.getPhysicalFilename\n            ? context.getPhysicalFilename()\n            : context.getFilename();\n\n          if (isHandlerFile(fileName) && node.tokens) {\n            const captureExceptionTokens = node.tokens\n              .filter((token) => token.type === \"Identifier\")\n              .filter((token) => token.value === \"captureException\");\n\n            // The capture exception token should be found in the file at least twice. Once\n            // for the import and then once when it is used to compose the handler.\n            if (captureExceptionTokens.length < 2) {\n              context.report({\n                node,\n                messageId: \"wrapFunctionWithCaptureException\",\n              });\n            }\n          }\n        },\n      };\n    },\n  },\n};\n"]}